 <!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Interactive Whiteboard</title>
    <style>
        :root {
            --primary: #4f46e5;
            --primary-dark: #4338ca;
            --accent: #818cf8;
            --danger: #ef4444;
            --success: #10b981;
            --light: #f9fafb;
            --dark: #111827;
            --toolbar-bg: #ffffff;
            --canvas-bg: #f3f4f6;
            --border: #e5e7eb;
        }
        
        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }
        
        body {
            font-family: 'Inter', -apple-system, BlinkMacSystemFont, sans-serif;
            background-color: var(--canvas-bg);
            color: var(--dark);
            height: 100vh;
            overflow: hidden;
        }
        
        #app {
            display: flex;
            flex-direction: column;
            height: 100vh;
        }
        
       #toolbar {
            display: flex;
            gap: 12px;
            margin: 12px;
            padding: 12px 16px;
            background-color: var(--toolbar-bg);
            border-radius: 12px;
            box-shadow: 0 4px 6px rgba(0,0,0,0.05);
            align-items: center;
            z-index: 10;
            flex-wrap: wrap;
        }
        
        .tool-group {
            display: flex;
            gap: 8px;
            align-items: center;
            padding: 0 8px;
            border-right: 1px solid var(--border);
        }
        
        .tool-group:last-child {
            border-right: none;
            margin-left: auto;
        }
        
        button {
            padding: 8px 16px;
            cursor: pointer;
            border: none;
            border-radius: 8px;
            background-color: var(--primary);
            color: white;
            font-size: 14px;
            font-weight: 500;
            transition: all 0.2s ease;
            display: flex;
            align-items: center;
            gap: 8px;
            box-shadow: 0 1px 2px rgba(0,0,0,0.05);
        }
        
        button:hover {
            background-color: var(--primary-dark);
            transform: translateY(-1px);
            box-shadow: 0 4px 6px rgba(0,0,0,0.1);
        }
        
        button:active {
            transform: translateY(0);
        }
        
        button.active {
            background-color: var(--primary-dark);
            box-shadow: inset 0 2px 4px rgba(0,0,0,0.1);
        }
        
        button.danger {
            background-color: var(--danger);
        }
        
        button.secondary {
            background-color: #6b7280;
        }

        button.home {
            background-color: var(--success);
        }
        
        #color-picker {
            width: 36px;
            height: 36px;
            padding: 0;
            border: 2px solid var(--border);
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s;
        }
        
        #brush-size {
            width: 100px;
            accent-color: var(--primary);
        }
        
        #canvas-size-input {
            padding: 8px 12px;
            border: 1px solid var(--border);
            border-radius: 8px;
            width: 120px;
            font-size: 14px;
        }
        
        #canvas-wrapper {
            flex: 1;
            overflow: hidden;
            margin: 0 12px 12px;
            border-radius: 12px;
            background-color: var(--canvas-bg);
            position: relative;
            box-shadow: inset 0 0 0 1px var(--border);
        }
        
        #canvas-scroll-container {
            width: 100%;
            height: 100%;
            overflow: auto;
            padding: 40px;
        }
        
        #canvas-container {
            position: relative;
            width: 10000px;
            height: 10000px;
            background-color: white;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            transform-origin: 0 0;
        }
        
        #drawing-canvas {
            position: absolute;
            top: 0;
            left: 0;
            cursor: crosshair;
            width: 100%;
            height: 100%;
        }
        #infinity-indicator {
    position: absolute;
    bottom: 120px;
    right: 24px;
    background-color: white;
    padding: 6px 12px;
    border-radius: 20px;
    font-size: 14px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.1);
    display: flex;
    align-items: center;
    gap: 6px;
}

        .resizable {
            position: absolute;
            border: 2px dashed transparent;
            min-width: 50px;
            min-height: 50px;
            resize: both;
            overflow: hidden;
            border-radius: 8px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            transition: all 0.2s;
            background-color: white;
        }
        
        .resizable:hover {
            border-color: var(--accent);
        }
        
        .selected {
            border-color: var(--primary) !important;
            box-shadow: 0 0 0 2px rgba(79, 70, 229, 0.3);
        }
        
        #mode-indicator {
            padding: 8px 16px;
            background-color: var(--primary);
            color: white;
            border-radius: 8px;
            font-weight: 500;
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 14px;
        }
        
        .icon {
            width: 18px;
            height: 18px;
        }
        
        .zoom-controls {
            position: absolute;
            bottom: 24px;
            right: 24px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 5;
        }
        
        .zoom-btn {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            background-color: white;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: all 0.2s;
        }
        
        .zoom-btn:hover {
            background-color: var(--light);
            transform: scale(1.05);
        }
        
        #zoom-level {
            position: absolute;
            bottom: 80px;
            right: 24px;
            background-color: white;
            padding: 6px 12px;
            border-radius: 20px;
            font-size: 14px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
        }
        
        #pan-mode-indicator {
            position: absolute;
            top: 16px;
            left: 50%;
            transform: translateX(-50%);
            background-color: rgba(0,0,0,0.7);
            color: white;
            padding: 8px 20px;
            border-radius: 20px;
            font-size: 14px;
            display: none;
            z-index: 10;
        }
        
        .size-input {
            display: flex;
            align-items: center;
            gap: 8px;
        }
        
        /* Modern scrollbar */
        ::-webkit-scrollbar {
            width: 10px;
            height: 10px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--border);
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb {
            background: #c7d2fe;
            border-radius: 10px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--accent);
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="toolbar">
            <div class="tool-group">
                <button id="home-btn" class="home" title="Back to Home">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path fill="currentColor" d="M10,20V14H14V20H19V12H22L12,3L2,12H5V20H10Z" />
                    </svg>
                    Home
                </button>
            </div>

            <div class="tool-group">
                <button id="draw-mode" class="active">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path fill="currentColor" d="M20.71,4.63L19.37,3.29C19,2.9 18.35,2.9 17.96,3.29L9,12.25L11.75,15L20.71,6.04C21.1,5.65 21.1,5 20.71,4.63M7,14A3,3 0 0,0 4,17C4,18.31 2.84,19 2,19C2.92,20.22 4.5,21 6,21A4,4 0 0,0 10,17A3,3 0 0,0 7,14Z" />
                    </svg>
                    Draw (D)
                </button>
                <button id="pan-mode" class="secondary">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path fill="currentColor" d="M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M7,9.5A1.5,1.5 0 0,1 8.5,8A1.5,1.5 0 0,1 10,9.5A1.5,1.5 0 0,1 8.5,11A1.5,1.5 0 0,1 7,9.5M12,17.23C10.25,17.23 8.71,16.5 7.81,15.42L9.23,14C9.68,14.72 10.75,15.23 12,15.23C13.25,15.23 14.32,14.72 14.77,14L16.19,15.42C15.29,16.5 13.75,17.23 12,17.23M17,10.5A1.5,1.5 0 0,1 15.5,12A1.5,1.5 0 0,1 14,10.5A1.5,1.5 0 0,1 15.5,9A1.5,1.5 0 0,1 17,10.5Z" />
                    </svg>
                    Pan (P)
                </button>
            </div>
            
            <div class="tool-group">
                <input type="color" id="color-picker" value="#4f46e5" title="Color">
                <div class="size-input">
                    <svg class="icon" viewBox="0 0 24 24" title="Brush size">
                        <path fill="currentColor" d="M20.71,4.63L19.37,3.29C19,2.9 18.35,2.9 17.96,3.29L9,12.25L11.75,15L20.71,6.04C21.1,5.65 21.1,5 20.71,4.63M7,14A3,3 0 0,0 4,17C4,18.31 2.84,19 2,19C2.92,20.22 4.5,21 6,21A4,4 0 0,0 10,17A3,3 0 0,0 7,14Z" />
                    </svg>
                    <input type="range" id="brush-size" min="1" max="50" value="5">
                </div>
            </div>
            
            <div class="tool-group">
                <button id="undo-btn" title="Undo (Ctrl+Z)">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path fill="currentColor" d="M12.5,8C9.85,8 7.45,9 5.6,10.6L2,7V16H11L7.38,12.38C8.77,11.22 10.54,10.5 12.5,10.5C16.04,10.5 19.05,12.81 20.1,16L22.47,15.22C21.08,11.03 17.15,8 12.5,8Z" />
                    </svg>
                    Undo
                </button>
                <button id="redo-btn" title="Redo (Ctrl+Y)">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path fill="currentColor" d="M18.4,10.6C16.55,9 14.15,8 11.5,8C6.85,8 2.92,11.03 1.54,15.22L3.9,16C4.95,12.81 7.95,10.5 11.5,10.5C13.45,10.5 15.23,11.22 16.62,12.38L13,16H22V7L18.4,10.6Z" />
                    </svg>
                    Redo
                </button>
                <button id="clear-btn" class="danger" title="Clear board">
                    <svg class="icon" viewBox="0 0 24 24">
                        <path fill="currentColor" d="M19,4H15.5L14.5,3H9.5L8.5,4H5V6H19M6,19A2,2 0 0,0 8,21H16A2,2 0 0,0 18,19V7H6V19Z" />
                    </svg>
                    Clear
                </button>
            </div>
            
            <div id="mode-indicator">
                <svg class="icon" viewBox="0 0 24 24">
                    <path fill="currentColor" d="M12,2A10,10 0 0,1 22,12A10,10 0 0,1 12,22A10,10 0 0,1 2,12A10,10 0 0,1 12,2M12,4A8,8 0 0,0 4,12A8,8 0 0,0 12,20A8,8 0 0,0 20,12A8,8 0 0,0 12,4Z" />
                </svg>
                <span>Mode: Drawing</span>
            </div>
        </div>
        
        <div id="canvas-wrapper">
            <div id="canvas-scroll-container">
                <div id="canvas-container">
                    <canvas id="drawing-canvas"></canvas>
                </div>
            </div>
            
            <div id="pan-mode-indicator">Pan mode (hold Space or middle mouse button)</div>
            
            <div id="zoom-level">100%</div>
            
            <div class="zoom-controls">
                <div class="zoom-btn" id="zoom-in">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <path fill="var(--primary)" d="M19,13H13V19H11V13H5V11H11V5H13V11H19V13Z" />
                    </svg>
                </div>
                <div class="zoom-btn" id="zoom-out">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <path fill="var(--primary)" d="M19,13H5V11H19V13Z" />
                    </svg>
                </div>
                <div class="zoom-btn" id="zoom-reset">
                    <svg width="24" height="24" viewBox="0 0 24 24">
                        <path fill="var(--primary)" d="M12,20A8,8 0 0,1 4,12A8,8 0 0,1 12,4A8,8 0 0,1 20,12A8,8 0 0,1 12,20M12,2A10,10 0 0,0 2,12A10,10 0 0,0 12,22A10,10 0 0,0 22,12A10,10 0 0,0 12,2M13,7H11V11H7V13H11V17H13V13H17V11H13V7Z" />
                    </svg>
                </div>
            </div>
        </div>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', function() {
    const canvas = document.getElementById('drawing-canvas');
    const ctx = canvas.getContext('2d', { willReadFrequently: false });
    const canvasContainer = document.getElementById('canvas-container');
    const canvasScrollContainer = document.getElementById('canvas-scroll-container');
    const colorPicker = document.getElementById('color-picker');
    const brushSize = document.getElementById('brush-size');
    const drawModeBtn = document.getElementById('draw-mode');
    const panModeBtn = document.getElementById('pan-mode');
    const undoBtn = document.getElementById('undo-btn');
    const redoBtn = document.getElementById('redo-btn');
    const clearBtn = document.getElementById('clear-btn');
    const modeIndicator = document.getElementById('mode-indicator');
    const zoomInBtn = document.getElementById('zoom-in');
    const zoomOutBtn = document.getElementById('zoom-out');
    const zoomResetBtn = document.getElementById('zoom-reset');
    const zoomLevel = document.getElementById('zoom-level');
    const panModeIndicator = document.getElementById('pan-mode-indicator');
    const homeBtn = document.getElementById('home-btn');
    
    // App state
    let isDrawing = false;
    let currentMode = 'draw';
    let history = [];
    let historyIndex = -1;
    let selectedElement = null;
    let offsetX, offsetY;
    let scale = 1;
    let isPanning = false;
    let panStartX, panStartY;
    let scrollLeftStart, scrollTopStart;
    let canvasWidth = 5000;
    let canvasHeight = 3000;
    let lastX = 0;
    let lastY = 0;
    let lastDrawTime = 0;
    let saveTimeout = null;
    
    // Оптимизация canvas
    canvas.style.imageRendering = 'optimizeSpeed';
    canvas.style.willChange = 'transform';
    canvas.style.backfaceVisibility = 'hidden';
    
    // Initialize canvas
    function initCanvas() {
        resizeCanvas();
        
        // Установка стилей для оптимизации
        ctx.imageSmoothingEnabled = false;
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        
        history = [canvas.toDataURL('image/png', 0.8)];
        historyIndex = 0;
        updateUndoRedoButtons();
        
        centerCanvas();
        setupEventListeners();
    }
    
    function resizeCanvas() {
        canvas.width = canvasWidth;
        canvas.height = canvasHeight;
    }
    
    function centerCanvas() {
        const containerWidth = canvasScrollContainer.clientWidth;
        const containerHeight = canvasScrollContainer.clientHeight;
        
        canvasScrollContainer.scrollLeft = (canvasContainer.clientWidth - containerWidth) / 2;
        canvasScrollContainer.scrollTop = (canvasContainer.clientHeight - containerHeight) / 2;
    }
    
    // Оптимизированная функция сохранения состояния
    function saveState(immediate = false) {
        if (saveTimeout) clearTimeout(saveTimeout);
        
        if (immediate) {
            _saveState();
        } else {
            saveTimeout = setTimeout(_saveState, 500);
        }
    }

    function _saveState() {
        if (historyIndex < history.length - 1) {
            history = history.slice(0, historyIndex + 1);
        }
        
        // Используем более легкий метод сохранения
        const tempCanvas = document.createElement('canvas');
        tempCanvas.width = canvas.width;
        tempCanvas.height = canvas.height;
        const tempCtx = tempCanvas.getContext('2d');
        tempCtx.drawImage(canvas, 0, 0);
        
        history.push(tempCanvas.toDataURL('image/png', 0.8));
        historyIndex++;
        
        if (history.length > 30) { // Уменьшили историю до 30 шагов
            history.shift();
            historyIndex--;
        }
        
        updateUndoRedoButtons();
    }
    
    function updateUndoRedoButtons() {
        undoBtn.disabled = historyIndex <= 0;
        redoBtn.disabled = historyIndex >= history.length - 1;
    }
    
    function restoreCanvasFromHistory() {
        if (historyIndex >= 0 && historyIndex < history.length) {
            const img = new Image();
            img.onload = function() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                ctx.drawImage(img, 0, 0);
            };
            img.src = history[historyIndex];
        }
    }
    
    function undo() {
        if (historyIndex > 0) {
            historyIndex--;
            restoreCanvasFromHistory();
            updateUndoRedoButtons();
        }
    }
    
    function redo() {
        if (historyIndex < history.length - 1) {
            historyIndex++;
            restoreCanvasFromHistory();
            updateUndoRedoButtons();
        }
    }
    
    function clearCanvas() {
        ctx.fillStyle = 'white';
        ctx.fillRect(0, 0, canvas.width, canvas.height);
        saveState(true);
        
        // Remove all elements
        document.querySelectorAll('.resizable').forEach(el => el.remove());
        selectedElement = null;
    }
    
    // Mode management
    function setMode(mode) {
        currentMode = mode;
        
        if (mode === 'draw') {
            canvas.style.cursor = 'crosshair';
            modeIndicator.querySelector('span').textContent = 'Mode: Drawing';
            drawModeBtn.classList.add('active');
            panModeBtn.classList.remove('active');
            
            if (selectedElement) {
                selectedElement.classList.remove('selected');
                selectedElement = null;
            }
        } else if (mode === 'pan') {
            canvas.style.cursor = 'grab';
            modeIndicator.querySelector('span').textContent = 'Mode: Pan';
            panModeBtn.classList.add('active');
            drawModeBtn.classList.remove('active');
            
            if (selectedElement) {
                selectedElement.classList.remove('selected');
                selectedElement = null;
            }
        }
    }
    
    // Оптимизированная функция рисования
    function draw(e) {
        if (!isDrawing || currentMode !== 'draw') return;
        
        const now = Date.now();
        if (now - lastDrawTime < 16) return; // Ограничиваем 60 FPS
        lastDrawTime = now;
        
        const { x, y } = getCanvasCoordinates(e);
        
        // Рисуем только если координаты изменились
        if (Math.abs(x - lastX) > 2 || Math.abs(y - lastY) > 2) {
            ctx.lineTo(x, y);
            ctx.stroke();
            lastX = x;
            lastY = y;
        }
    }
    
    function startDrawing(e) {
        if (currentMode !== 'draw') return;
        
        isDrawing = true;
        const { x, y } = getCanvasCoordinates(e);
        ctx.beginPath();
        ctx.moveTo(x, y);
        ctx.strokeStyle = colorPicker.value;
        ctx.lineWidth = brushSize.value;
        ctx.lineCap = 'round';
        ctx.lineJoin = 'round';
        lastX = x;
        lastY = y;
    }
    
    function stopDrawing() {
        if (!isDrawing || currentMode !== 'draw') return;
        
        isDrawing = false;
        saveState();
    }
    
    // Оптимизированное создание элементов
    function createNewElement(x, y) {
        const containerRect = canvasContainer.getBoundingClientRect();
        x = (x - containerRect.left) / scale;
        y = (y - containerRect.top) / scale;
        
        const element = document.createElement('div');
        element.className = 'resizable selected';
        element.style.left = x + 'px';
        element.style.top = y + 'px';
        element.style.width = '100px';
        element.style.height = '100px';
        element.style.backgroundColor = colorPicker.value;
        
        // Улучшенный обработчик для элементов
        function handleMouseDown(e) {
            if (selectedElement) {
                selectedElement.classList.remove('selected');
            }
            selectedElement = element;
            element.classList.add('selected');
            
            const rect = element.getBoundingClientRect();
            offsetX = e.clientX - rect.left;
            offsetY = e.clientY - rect.top;
            
            function handleMouseMove(e) {
                moveElement(e);
            }
            
            function handleMouseUp() {
                document.removeEventListener('mousemove', handleMouseMove);
                document.removeEventListener('mouseup', handleMouseUp);
            }
            
            document.addEventListener('mousemove', handleMouseMove);
            document.addEventListener('mouseup', handleMouseUp, { once: true });
            
            e.stopPropagation();
        }
        
        element.addEventListener('mousedown', handleMouseDown);
        canvasContainer.appendChild(element);
        selectedElement = element;
        
        saveState(true);
    }
    
    function moveElement(e) {
        if (!selectedElement) return;
        
        const containerRect = canvasContainer.getBoundingClientRect();
        let newX = e.clientX - offsetX - containerRect.left;
        let newY = e.clientY - offsetY - containerRect.top;
        
        newX = Math.max(0, Math.min(newX, containerRect.width - selectedElement.offsetWidth));
        newY = Math.max(0, Math.min(newY, containerRect.height - selectedElement.offsetHeight));
        
        selectedElement.style.left = newX + 'px';
        selectedElement.style.top = newY + 'px';
    }
    
    // Оптимизация масштабирования
    function updateZoom() {
        // Используем will-change для оптимизации анимации
        canvasContainer.style.willChange = 'transform';
        canvasContainer.style.transform = `scale(${scale})`;
        zoomLevel.textContent = `${Math.round(scale * 100)}%`;
        
        // Сбрасываем will-change после анимации
        setTimeout(() => {
            canvasContainer.style.willChange = 'auto';
        }, 300);
    }
    
    function zoomIn() {
        scale = Math.min(scale + 0.1, 3);
        updateZoom();
    }
    
    function zoomOut() {
        scale = Math.max(scale - 0.1, 0.5);
        updateZoom();
    }
    
    function zoomReset() {
        scale = 1;
        updateZoom();
        centerCanvas();
    }
    
    // Оптимизированная функция getCanvasCoordinates
    let canvasRect;
    let lastRectUpdate = 0;
    function getCanvasCoordinates(e) {
        const now = Date.now();
        if (!canvasRect || now - lastRectUpdate > 100) {
            canvasRect = canvas.getBoundingClientRect();
            lastRectUpdate = now;
        }
        
        const scaleX = canvas.width / canvasRect.width;
        const scaleY = canvas.height / canvasRect.height;
        return {
            x: (e.clientX - canvasRect.left) * scaleX,
            y: (e.clientY - canvasRect.top) * scaleY
        };
    }
    
    // Pan functionality
    function startPan(e) {
        if (currentMode !== 'pan' && !(e.type === 'mousedown' && e.button === 1) && !(e.type === 'keydown' && e.code === 'Space')) return;
        
        isPanning = true;
        panStartX = e.clientX;
        panStartY = e.clientY;
        scrollLeftStart = canvasScrollContainer.scrollLeft;
        scrollTopStart = canvasScrollContainer.scrollTop;
        
        canvas.style.cursor = 'grabbing';
        panModeIndicator.style.display = 'block';
        
        e.preventDefault();
    }
    
    function doPan(e) {
        if (!isPanning) return;
        
        const dx = e.clientX - panStartX;
        const dy = e.clientY - panStartY;
        
        canvasScrollContainer.scrollLeft = scrollLeftStart - dx;
        canvasScrollContainer.scrollTop = scrollTopStart - dy;
    }
    
    function stopPan() {
        if (!isPanning) return;
        
        isPanning = false;
        canvas.style.cursor = currentMode === 'pan' ? 'grab' : 'default';
        panModeIndicator.style.display = 'none';
    }

    // Home button functionality
    function goToHome() {
        window.location.href = 'index.html';
    }
    
    // Оптимизированные обработчики событий
    function setupEventListeners() {
        // Используем passive события для скролла
        canvasScrollContainer.addEventListener('scroll', () => {}, { passive: true });
        
        // Оптимизированные обработчики мыши
        canvas.addEventListener('mousedown', startDrawing, { passive: false });
        canvas.addEventListener('mousemove', draw, { passive: true });
        canvas.addEventListener('mouseup', stopDrawing, { passive: true });
        canvas.addEventListener('mouseout', stopDrawing, { passive: true });
        
        // Object creation
        canvasContainer.addEventListener('mousedown', function(e) {
            if (currentMode !== 'draw' || e.target !== canvasContainer) return;
            createNewElement(e.clientX, e.clientY);
        });
        
        // Обработчики панорамирования
        canvasScrollContainer.addEventListener('mousedown', startPan, { passive: false });
        document.addEventListener('mousemove', doPan, { passive: true });
        document.addEventListener('mouseup', stopPan, { passive: true });
        
        // Pan with middle mouse button
        canvasScrollContainer.addEventListener('mousedown', function(e) {
            if (e.button === 1) {
                startPan(e);
            }
        });
        
        // Обработчики кнопок
        drawModeBtn.addEventListener('click', () => setMode('draw'));
        panModeBtn.addEventListener('click', () => setMode('pan'));
        undoBtn.addEventListener('click', undo);
        redoBtn.addEventListener('click', redo);
        clearBtn.addEventListener('click', clearCanvas);
        zoomInBtn.addEventListener('click', zoomIn);
        zoomOutBtn.addEventListener('click', zoomOut);
        zoomResetBtn.addEventListener('click', zoomReset);
        homeBtn.addEventListener('click', goToHome);
        
        // Глобальные обработчики
        document.addEventListener('keydown', handleKeyDown);
        document.addEventListener('keyup', handleKeyUp);
    }
    
    function handleKeyDown(e) {
        if (e.ctrlKey && e.key === 'z') {
            undo();
            e.preventDefault();
        } else if (e.ctrlKey && e.key === 'y') {
            redo();
            e.preventDefault();
        } else if (e.code === 'Space' && !isPanning) {
            setMode('pan');
            canvas.style.cursor = 'grab';
            panModeIndicator.style.display = 'block';
        } else if (e.key === 'd' || e.key === 'D') {
            setMode('draw');
        } else if (e.key === 'p' || e.key === 'P') {
            setMode('pan');
        } else if (e.key === '+' || e.key === '=') {
            zoomIn();
            e.preventDefault();
        } else if (e.key === '-' || e.key === '_') {
            zoomOut();
            e.preventDefault();
        } else if (e.key === '0') {
            zoomReset();
            e.preventDefault();
        }
    }
    
    function handleKeyUp(e) {
        if (e.code === 'Space' && currentMode === 'pan') {
            setMode('draw');
            stopPan();
        }
    }
    
    // Initialize
    initCanvas();
    updateZoom();
    setMode('draw');
});
</script> 
</body>
</html>
 